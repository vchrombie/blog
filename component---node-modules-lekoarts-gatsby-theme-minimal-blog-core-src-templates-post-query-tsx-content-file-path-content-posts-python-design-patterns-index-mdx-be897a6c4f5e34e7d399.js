"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[348],{9876:function(e,n,t){t.r(n),t.d(n,{Head:function(){return l.p},default:function(){return p}});var s=t(6540),r=t(8453);function o(e){const n=Object.assign({p:"p",h2:"h2",pre:"pre",code:"code"},(0,r.RP)(),e.components);return s.createElement(s.Fragment,null,s.createElement(n.p,null,"Design patterns are reusable solutions to common problems in software design. They are like blueprints that you can customize to solve particular design problems in your code. In this blog post, we'll cover some of the most common design patterns in Python: Singleton, Composite, Factory, and Proxy. Let's dive into each one with simple explanations and examples."),"\n",s.createElement(n.h2,null,"Singleton Design Pattern"),"\n",s.createElement(n.p,null,"The Singleton Design Pattern ensures that a class has only one instance and provides a global point of access to it. This is useful when exactly one object is needed to coordinate actions across a system."),"\n",s.createElement(n.pre,null,s.createElement(n.code,{className:"language-python"},'from abc import ABC, abstractmethod\n\n\nclass IPerson(ABC):\n    @abstractmethod\n    def person_type(self):\n        # Interface method\n        pass\n\n\nclass Person(IPerson):\n\n    __instance = None\n\n    def get_instance():\n        if Person.__instance is None:\n            Person("Default", 0)\n        return Person.__instance\n\n    def __init__(self, name, age):\n        if Person.__instance is not None:\n            raise Exception("This class is a singleton!")\n        else:\n            self.name = name\n            self.age = age\n            Person.__instance = self\n\n    @staticmethod\n    def person_type():\n        print(f"Person Name: {Person.__instance.name}")\n        print(f"Person Age: {Person.__instance.age}")\n\n\np1 = Person("John", 25)\nprint(p1)\np1.person_type()\n# <__main__.Person object at 0x100eb5ca0>\n# Person Name: John\n# Person Age: 25\n\np3 = Person.get_instance()\nprint(p3)\np3.person_type()\n# <__main__.Person object at 0x100eb5ca0>\n# Person Name: John\n# Person Age: 25\n\np2 = Person("Jack", 30)\n# Exception: This class is a singleton!\n')),"\n",s.createElement(n.h2,null,"Composite Design Pattern"),"\n",s.createElement(n.p,null,"The Composite Design Pattern allows you to compose objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects and compositions of objects uniformly."),"\n",s.createElement(n.pre,null,s.createElement(n.code,{className:"language-python"},'from abc import ABC, abstractmethod, abstractstaticmethod\n\n\nclass IDepartment(ABC):\n    @abstractmethod\n    def __init__(self, employees):\n        # Interface method\n        pass\n\n    @abstractstaticmethod\n    def get_name():\n        # Interface method\n        pass\n\n\nclass Accounting(IDepartment):\n    def __init__(self, employees):\n        self.employees = employees\n\n    def get_name(self):\n        print("Accounting {}".format(self.employees))\n\n\nclass Development(IDepartment):\n    def __init__(self, employees):\n        self.employees = employees\n\n    def get_name(self):\n        print("Development {}".format(self.employees))\n\n\nclass ParentDepartment(IDepartment):\n    def __init__(self, employees):\n        self.employees = employees\n        self.base_employees = employees\n        self.departments = []\n\n    def add_department(self, department):\n        self.departments.append(department)\n        self.employees += department.employees\n\n    def get_name(self):\n        print("Parent Department {}".format(self.base_employees))\n        for department in self.departments:\n            department.get_name()\n        print("Total Employees {}".format(self.employees))\n\n\nd1 = Accounting(200)\nd2 = Development(300)\nd3 = ParentDepartment(50)\nd3.add_department(d1)\nd3.add_department(d2)\n\nd3.get_name()\n# Parent Department 50\n# Accounting 200\n# Development 300\n# Total Employees: 550\n')),"\n",s.createElement(n.h2,null,"Factory Design Pattern"),"\n",s.createElement(n.p,null,"The Factory Method Pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses."),"\n",s.createElement(n.pre,null,s.createElement(n.code,{className:"language-python"},'from abc import ABC, abstractmethod\n\n\nclass IPerson(ABC):\n    @abstractmethod\n    def person_type(self):\n        # Interface method\n        pass\n\n\n# p = IPerson()\n# TypeError: Can\'t instantiate abstract class IPerson\n# with abstract method person_type\n\nclass Teacher(IPerson):\n    def person_type(self):\n        return "Teacher"\n\n\nclass Student(IPerson):\n    def person_type(self):\n        return "Student"\n\n\nt = Teacher()\nprint(t.person_type())  # Teacher\n\ns = Student()\nprint(s.person_type())  # Student\n\n\nclass PersonFactory:\n\n    @staticmethod\n    def get_person(person_type):\n        if person_type == "Teacher":\n            return Teacher()\n        if person_type == "Student":\n            return Student()\n        raise TypeError("Invalid person type")\n\n\nperson_type = input("Enter person type (Teacher/Student): ")\ntry:\n    person = PersonFactory.get_person(person_type)\nexcept TypeError as e:\n    print(e)\nelse:\n    print(person.person_type())\n')),"\n",s.createElement(n.h2,null,"Proxy Design Pattern"),"\n",s.createElement(n.p,null,"The Proxy Design Pattern provides a surrogate or placeholder for another object to control access to it. The proxy object acts as an intermediary between the client and the real object, performing various tasks such as lazy initialization, access control, logging, etc."),"\n",s.createElement(n.pre,null,s.createElement(n.code,{className:"language-python"},'from abc import ABC, abstractmethod\n\n\nclass IPerson(ABC):\n    @abstractmethod\n    def person_type(self):\n        # Interface method\n        pass\n\n\nclass Person(IPerson):\n    def person_type(self):\n        return "Person"\n\n\nclass ProxyPerson(IPerson):\n    def __init__(self):\n        self.person = Person()\n\n    def person_type(self):\n        return "Proxy " + self.person.person_type()\n\n\np1 = Person()\nprint(p1.person_type())\n# Person\n\np2 = ProxyPerson()\nprint(p2.person_type())\n# Proxy Person\n')),"\n",s.createElement(n.h2,null,"Conclusion"),"\n",s.createElement(n.p,null,"These design patterns provide a solid foundation for solving common design problems. By understanding and using these patterns, you can create more flexible, reusable, and maintainable code."))}var a=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,r.RP)(),e.components);return n?s.createElement(n,e,s.createElement(o,e)):o(e)},l=t(7932);function p(e){return s.createElement(l.A,e,s.createElement(a,e))}l.A}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-python-design-patterns-index-mdx-be897a6c4f5e34e7d399.js.map